/***** DAY 7 *****/
/* SETUP */

DECLARE @inp varchar(max) = 'af AND ah -> ai
NOT lk -> ll
hz RSHIFT 1 -> is
NOT go -> gp
du OR dt -> dv
x RSHIFT 5 -> aa
at OR az -> ba
eo LSHIFT 15 -> es
ci OR ct -> cu
b RSHIFT 5 -> f
fm OR fn -> fo
NOT ag -> ah
v OR w -> x
g AND i -> j
an LSHIFT 15 -> ar
1 AND cx -> cy
jq AND jw -> jy
iu RSHIFT 5 -> ix
gl AND gm -> go
NOT bw -> bx
jp RSHIFT 3 -> jr
hg AND hh -> hj
bv AND bx -> by
er OR es -> et
kl OR kr -> ks
et RSHIFT 1 -> fm
e AND f -> h
u LSHIFT 1 -> ao
he RSHIFT 1 -> hx
eg AND ei -> ej
bo AND bu -> bw
dz OR ef -> eg
dy RSHIFT 3 -> ea
gl OR gm -> gn
da LSHIFT 1 -> du
au OR av -> aw
gj OR gu -> gv
eu OR fa -> fb
lg OR lm -> ln
e OR f -> g
NOT dm -> dn
NOT l -> m
aq OR ar -> as
gj RSHIFT 5 -> gm
hm AND ho -> hp
ge LSHIFT 15 -> gi
jp RSHIFT 1 -> ki
hg OR hh -> hi
lc LSHIFT 1 -> lw
km OR kn -> ko
eq LSHIFT 1 -> fk
1 AND am -> an
gj RSHIFT 1 -> hc
aj AND al -> am
gj AND gu -> gw
ko AND kq -> kr
ha OR gz -> hb
bn OR by -> bz
iv OR jb -> jc
NOT ac -> ad
bo OR bu -> bv
d AND j -> l
bk LSHIFT 1 -> ce
de OR dk -> dl
dd RSHIFT 1 -> dw
hz AND ik -> im
NOT jd -> je
fo RSHIFT 2 -> fp
hb LSHIFT 1 -> hv
lf RSHIFT 2 -> lg
gj RSHIFT 3 -> gl
ki OR kj -> kk
NOT ak -> al
ld OR le -> lf
ci RSHIFT 3 -> ck
1 AND cc -> cd
NOT kx -> ky
fp OR fv -> fw
ev AND ew -> ey
dt LSHIFT 15 -> dx
NOT ax -> ay
bp AND bq -> bs
NOT ii -> ij
ci AND ct -> cv
iq OR ip -> ir
x RSHIFT 2 -> y
fq OR fr -> fs
bn RSHIFT 5 -> bq
0 -> c
14146 -> b
d OR j -> k
z OR aa -> ab
gf OR ge -> gg
df OR dg -> dh
NOT hj -> hk
NOT di -> dj
fj LSHIFT 15 -> fn
lf RSHIFT 1 -> ly
b AND n -> p
jq OR jw -> jx
gn AND gp -> gq
x RSHIFT 1 -> aq
ex AND ez -> fa
NOT fc -> fd
bj OR bi -> bk
as RSHIFT 5 -> av
hu LSHIFT 15 -> hy
NOT gs -> gt
fs AND fu -> fv
dh AND dj -> dk
bz AND cb -> cc
dy RSHIFT 1 -> er
hc OR hd -> he
fo OR fz -> ga
t OR s -> u
b RSHIFT 2 -> d
NOT jy -> jz
hz RSHIFT 2 -> ia
kk AND kv -> kx
ga AND gc -> gd
fl LSHIFT 1 -> gf
bn AND by -> ca
NOT hr -> hs
NOT bs -> bt
lf RSHIFT 3 -> lh
au AND av -> ax
1 AND gd -> ge
jr OR js -> jt
fw AND fy -> fz
NOT iz -> ja
c LSHIFT 1 -> t
dy RSHIFT 5 -> eb
bp OR bq -> br
NOT h -> i
1 AND ds -> dt
ab AND ad -> ae
ap LSHIFT 1 -> bj
br AND bt -> bu
NOT ca -> cb
NOT el -> em
s LSHIFT 15 -> w
gk OR gq -> gr
ff AND fh -> fi
kf LSHIFT 15 -> kj
fp AND fv -> fx
lh OR li -> lj
bn RSHIFT 3 -> bp
jp OR ka -> kb
lw OR lv -> lx
iy AND ja -> jb
dy OR ej -> ek
1 AND bh -> bi
NOT kt -> ku
ao OR an -> ap
ia AND ig -> ii
NOT ey -> ez
bn RSHIFT 1 -> cg
fk OR fj -> fl
ce OR cd -> cf
eu AND fa -> fc
kg OR kf -> kh
jr AND js -> ju
iu RSHIFT 3 -> iw
df AND dg -> di
dl AND dn -> do
la LSHIFT 15 -> le
fo RSHIFT 1 -> gh
NOT gw -> gx
NOT gb -> gc
ir LSHIFT 1 -> jl
x AND ai -> ak
he RSHIFT 5 -> hh
1 AND lu -> lv
NOT ft -> fu
gh OR gi -> gj
lf RSHIFT 5 -> li
x RSHIFT 3 -> z
b RSHIFT 3 -> e
he RSHIFT 2 -> hf
NOT fx -> fy
jt AND jv -> jw
hx OR hy -> hz
jp AND ka -> kc
fb AND fd -> fe
hz OR ik -> il
ci RSHIFT 1 -> db
fo AND fz -> gb
fq AND fr -> ft
gj RSHIFT 2 -> gk
cg OR ch -> ci
cd LSHIFT 15 -> ch
jm LSHIFT 1 -> kg
ih AND ij -> ik
fo RSHIFT 3 -> fq
fo RSHIFT 5 -> fr
1 AND fi -> fj
1 AND kz -> la
iu AND jf -> jh
cq AND cs -> ct
dv LSHIFT 1 -> ep
hf OR hl -> hm
km AND kn -> kp
de AND dk -> dm
dd RSHIFT 5 -> dg
NOT lo -> lp
NOT ju -> jv
NOT fg -> fh
cm AND co -> cp
ea AND eb -> ed
dd RSHIFT 3 -> df
gr AND gt -> gu
ep OR eo -> eq
cj AND cp -> cr
lf OR lq -> lr
gg LSHIFT 1 -> ha
et RSHIFT 2 -> eu
NOT jh -> ji
ek AND em -> en
jk LSHIFT 15 -> jo
ia OR ig -> ih
gv AND gx -> gy
et AND fe -> fg
lh AND li -> lk
1 AND io -> ip
kb AND kd -> ke
kk RSHIFT 5 -> kn
id AND if -> ig
NOT ls -> lt
dw OR dx -> dy
dd AND do -> dq
lf AND lq -> ls
NOT kc -> kd
dy AND ej -> el
1 AND ke -> kf
et OR fe -> ff
hz RSHIFT 5 -> ic
dd OR do -> dp
cj OR cp -> cq
NOT dq -> dr
kk RSHIFT 1 -> ld
jg AND ji -> jj
he OR hp -> hq
hi AND hk -> hl
dp AND dr -> ds
dz AND ef -> eh
hz RSHIFT 3 -> ib
db OR dc -> dd
hw LSHIFT 1 -> iq
he AND hp -> hr
NOT cr -> cs
lg AND lm -> lo
hv OR hu -> hw
il AND in -> io
NOT eh -> ei
gz LSHIFT 15 -> hd
gk AND gq -> gs
1 AND en -> eo
NOT kp -> kq
et RSHIFT 5 -> ew
lj AND ll -> lm
he RSHIFT 3 -> hg
et RSHIFT 3 -> ev
as AND bd -> bf
cu AND cw -> cx
jx AND jz -> ka
b OR n -> o
be AND bg -> bh
1 AND ht -> hu
1 AND gy -> gz
NOT hn -> ho
ck OR cl -> cm
ec AND ee -> ef
lv LSHIFT 15 -> lz
ks AND ku -> kv
NOT ie -> if
hf AND hl -> hn
1 AND r -> s
ib AND ic -> ie
hq AND hs -> ht
y AND ae -> ag
NOT ed -> ee
bi LSHIFT 15 -> bm
dy RSHIFT 2 -> dz
ci RSHIFT 2 -> cj
NOT bf -> bg
NOT im -> in
ev OR ew -> ex
ib OR ic -> id
bn RSHIFT 2 -> bo
dd RSHIFT 2 -> de
bl OR bm -> bn
as RSHIFT 1 -> bl
ea OR eb -> ec
ln AND lp -> lq
kk RSHIFT 3 -> km
is OR it -> iu
iu RSHIFT 2 -> iv
as OR bd -> be
ip LSHIFT 15 -> it
iw OR ix -> iy
kk RSHIFT 2 -> kl
NOT bb -> bc
ci RSHIFT 5 -> cl
ly OR lz -> ma
z AND aa -> ac
iu RSHIFT 1 -> jn
cy LSHIFT 15 -> dc
cf LSHIFT 1 -> cz
as RSHIFT 3 -> au
cz OR cy -> da
kw AND ky -> kz
lx -> a
iw AND ix -> iz
lr AND lt -> lu
jp RSHIFT 5 -> js
aw AND ay -> az
jc AND je -> jf
lb OR la -> lc
NOT cn -> co
kh LSHIFT 1 -> lb
1 AND jj -> jk
y OR ae -> af
ck AND cl -> cn
kk OR kv -> kw
NOT cv -> cw
kl AND kr -> kt
iu OR jf -> jg
at AND az -> bb
jp RSHIFT 2 -> jq
iv AND jb -> jd
jn OR jo -> jp
x OR ai -> aj
ba AND bc -> bd
jl OR jk -> jm
b RSHIFT 1 -> v
o AND q -> r
NOT p -> q
k AND m -> n
as RSHIFT 2 -> at';


/**** TEST */
/*
DECLARE @inp varchar(max) = '123 -> x
456 -> y
x AND y -> d
x OR y -> e
x LSHIFT 2 -> f
y RSHIFT 2 -> g
NOT x -> h
NOT y -> i'
*/
--SELECT  @inp

DECLARE @CRLF varchar(10) = char(13) + char(10) ;
DECLARE @inStr varchar(max) = REPLACE(@inp,@CRLF,'|')


/* Instructions table. */
DROP TABLE IF EXISTS #tmpInstructions
CREATE TABLE #tmpInstructions (id int identity, instr varchar(max), i1 varchar(20), i2 varchar(20), logic varchar(50), result varchar(20), dest varchar(10))

INSERT INTO #tmpInstructions (instr)
SELECT value FROM STRING_SPLIT(@inStr,'|')

--SELECT * FROM #tmpInstructions

/* PART 2 CHANGE */

UPDATE #tmpInstructions
SET instr = '956=b'
WHERE id = 90


/**** 90	14146=b */
/*****************/


/* Final State Table. */
DROP TABLE IF EXISTS #finalState
CREATE TABLE #finalState (wireID int identity, wireName varchar(10), wireValue int)


/* Parse instructions for bitwise operators and parts. */
/*
AND = &
OR = |
NOT = ~
LSHIFT = <
RSHIFT = >

EQUALS = =
*/

UPDATE #tmpInstructions
SET instr = 
	REPLACE(
		REPLACE(
			REPLACE(
				REPLACE(
					REPLACE(
						REPLACE(
							REPLACE(instr,'->','=')
							, 'AND', '&'
						)
						, 'OR', '|'
					)
					, 'NOT','~'
				)
				, 'LSHIFT','<'
			)
			, 'RSHIFT','>'
		)
		, ' ', ''
	)



/* SET KNOWN VALUES */
; WITH base AS (
	SELECT id
		, SUBSTRING( instr, 1, CHARINDEX('=', instr)-1) AS chrResult
		, SUBSTRING( instr, CHARINDEX('=', instr)+1,len(instr)) AS chrDest
	FROM #tmpInstructions
)
UPDATE #tmpInstructions
SET result = CASE WHEN TRY_CONVERT(int,base.chrResult) IS NOT NULL THEN base.chrResult ELSE NULL END
	, dest = base.chrDest
	, logic = CASE 
				WHEN CHARINDEX('&', instr) > 0 THEN '&'
				WHEN CHARINDEX('|', instr) > 0 THEN '|'
				WHEN CHARINDEX('~', instr) > 0 THEN '~'
				WHEN CHARINDEX('<', instr) > 0 THEN '<'
				WHEN CHARINDEX('>', instr) > 0 THEN '>'
				ELSE NULL
			END
FROM base	
WHERE #tmpInstructions.id = base.id
	AND logic IS NULL
	

UPDATE #tmpInstructions
SET 
	  i1 = SUBSTRING( instr, 1, PATINDEX('%[&|<>]%', instr)-1)
	
	, i2 = SUBSTRING( instr, PATINDEX('%[&|<>]%', instr)+1 , CHARINDEX('=', instr)-1 - PATINDEX('%[&|<>]%', instr))
WHERE logic IN ('&','|','<','>')

UPDATE #tmpInstructions
SET 
	  i1 = NULL
	, i2 = SUBSTRING( instr, 2, 2 - CHARINDEX('=', instr)-2 + LEN(instr)  )
WHERE logic = '~'


UPDATE #tmpInstructions
SET i2 = SUBSTRING( instr, 1 , CHARINDEX('=', instr)-1 - PATINDEX('%[&|<>]%', instr))
	, logic = '='
WHERE logic IS NULL



--SELECT * FROM  #tmpInstructions

/***********/
/* This is where I need to iterate over these processes until all results are populated. */
WHILE (1=1)
BEGIN

	; WITH fins AS (
		SELECT dest, result
		FROM #tmpInstructions
		WHERE result IS NOT NULL
	)
	UPDATE  #tmpInstructions
	SET i1 = fins.result
	FROM fins 
	WHERE #tmpInstructions.i1 = fins.dest
	
	; WITH fins AS (
		SELECT dest, result
		FROM #tmpInstructions
		WHERE result IS NOT NULL
	)
	UPDATE  #tmpInstructions
	SET i2 = fins.result
	FROM fins 
	WHERE #tmpInstructions.i2 = fins.dest


	--SELECT * FROM  #tmpInstructions

	/*  https://dataeducation.com/bitmask-handling-part-4-left-shift-and-right-shift/ */

	UPDATE #tmpInstructions
	SET result = 
		CASE 
			WHEN logic = '&' THEN TRY_CONVERT(int, i1) & TRY_CONVERT(int, i2)
			WHEN logic = '|' THEN TRY_CONVERT(int, i1) | TRY_CONVERT(int, i2)
		
			WHEN logic = '~' THEN 65536 + ~TRY_CONVERT(smallint, i2)

			WHEN logic = '<' THEN TRY_CONVERT(smallint, i1) << TRY_CONVERT(int, i2)
			WHEN logic = '>' THEN TRY_CONVERT(smallint, i1) >> TRY_CONVERT(int, i2)

			WHEN logic = '=' THEN CASE WHEN TRY_CONVERT(int,i2) < 0 THEN 65536+TRY_CONVERT(int,i2) ELSE TRY_CONVERT(int,i2) END
		END
	WHERE result IS NULL
	
	IF (@@ROWCOUNT = 0)
	BEGIN
		BREAK
	END
END
/***********/

/* PART 1 */
SELECT * 
FROM #tmpInstructions 
WHERE dest = 'a'

/* ANSWER */
-- 956 = CORRECT!

/* PART 2 */
SELECT * 
FROM #tmpInstructions 
WHERE dest = 'a'

/* ANSWER */
-- -25387 <<< INCORRECT
-- 40149 <<< CORRECT!

/*
NOTES:
Coming back to this one yet again. It's December 2023. This problem is Bitwise logic, and 
I have no idea why I abandoned it before. Probably becauase the logic was weird. Let's 
give it another go.

Part 1:
Part 1 seems to be a parsing then calculating thing. It doesn't seem to crazy, just a 
complex set of operations to follow. 

I'll start with parsing these instructions into a table, keeping in mind that SQL has 
no guarantee of order without ORDER BY. That hasn't bit me yet, but there's always a first
time.

I think I need an table for instructions and results. I probably also need a table for 
the final state of each wire in my set. I think the first thing I need to do is pull out
the wires that are assigned a value, so that I have an initial state. I can't do bitwise
logic on a wire that doesn't have a value. Then I think I need to work backwards from there 
and apply those values to the related wires. Let's see what that gets me. 

...

Most of the bit logic wasn't too bad, but I'm using SQL 2016, and Microsoft didn't 
introduce bit shifting until SQL 2022. It's possible with actual bit math, but that's 
out of where I'm at right now. Temporary roadblock. I'll work on it later. 

...

Picking back up the next morning, and the first thing I realize is that I don't want to 
worry with figuring out bit-shifting in SQL 2016. I _think_ I understand the process, but I
still don't feel like worrying with it. It's rather get on with solving the problem. So it's
time to spin up a SQL 2022 Docker container on my local machine. Docker is so cool. 

But anyway, now that I've got SQL 2022 running, I can do my bit twiddling with ">>" and "<<".
First try comes out as the wrong numbers. I'm thankful for the initial Test instructions. 

Reading more carefully, I see that each wire can "...carry a 16-bit signal (a number from 
0 to 65535)." So that's why my numbers are different. I shift my algorithms around a bit 
and finally get them to match up with expectations.

Back on track.

I realize that I'm going to have to loop over my calculations block to keep whittling down
the variables until they're all numbers that can be worked with to calculate a result. 
But before I do that, I want to run my puzzle data to see what it looks like. 

And the first thing I notice is that some blocks are "variable1 = variable2" without any 
bit twiddling. So I need to fix my algorithms to add that logic in there...

Now that's done, I fiddle around with it a bit again and finally get it to spit out what
I need. Time to set the loop...

That wasn't really difficult. I just used a WHILE 1=1 infinite loop to keep looping over
my queries to update my table, setting the variables to a numeric value as they are 
solved, then calculating a result where possible. I leave NULL until I can calc the 
variable, and I just loop over the table until I don't have any unfilled results. 

It was ugly, and I could probably do this much more efficiently, but again, I just want
a result first. 

I finally get a calculation for the Part 1 Solution, and when I enter it to check, it's
CORRECT!

Part 1 Complete!

-- ATTEMPT 1: 
956 >> CORRECT!

Part 2:
WTAF??? Now it wants me to override Wire B with the value from Wire A. I'm gonna have to
think about this one for a few minutes just to figure out exactly what he's asking...

Well, if it really means to just change the initial value of B to the Part 1 value of A, 
then I just change the instr column to be "956=b" and run it again. Let's see what 
happens...

New result: -25387 <<< THAT'S NOT THE RIGHT ANSWER.

Argh, I suspect it has something to do with 16-bit wires, which are 0-65535, so I 
shouldn't have any negative numbers. I missed a calc somewhere...

UGH... I was right. I had to factor in the 16-bit numbers, so when I got to the 
final result again, I just subtracted the result from 65535 if it was negative. This
ensured that my result was always between 0-65535.

New result: 40149 << CORRECT!

Day 7 complete. My head hurts.


-- ATTEMPT 1: -25387 <<< INCORRECT
-- ATTEMPT 2: 40149 <<< CORRECT!

*/





